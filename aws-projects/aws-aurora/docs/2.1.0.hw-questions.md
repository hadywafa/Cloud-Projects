### ğŸ”¥ **Deep Dive: How Writes Work in Amazon Auroraâ€™s Distributed Storage**

You're **asking the right questions** about **how Amazon Aurora handles writes**, specifically:

- **Why do redo logs go to all storage nodes, even though each node contains only part of the data?**
- **How does Aurora apply writes? (In-memory or directly on disk?)**
- **How does Aurora handle multiple databases in a cluster?**

Let's break it all down in a **detailed, step-by-step** explanation. ğŸš€ğŸ”¥

---

## ğŸ— **1ï¸âƒ£ Why Does the Redo Log Go to All Storage Nodes?**

Auroraâ€™s **redo log replication mechanism** ensures **distributed consistency** without traditional WAL (Write-Ahead Logging). However, **it does NOT send every redo log to every storage node.** Instead:

âœ” **The redo log is only sent to the specific storage nodes** that store the affected data shards.  
âœ” Storage nodes **only process writes for the Protection Groups they own**.  
âœ” **Nodes that do not store the relevant data simply ignore the log entry.**

### ğŸ”¹ **Step-by-Step Write Process**

1ï¸âƒ£ **The client sends an `INSERT/UPDATE` query to the primary Aurora DB instance.**  
2ï¸âƒ£ **The Query Engine determines which Protection Groups contain the affected data.**  
3ï¸âƒ£ **Only the storage nodes responsible for those Protection Groups receive the redo log.**  
4ï¸âƒ£ **Each storage node applies the redo log to its in-memory cache first** before writing to disk.  
5ï¸âƒ£ **Once at least 4 out of 6 nodes acknowledge the redo log, the transaction is committed.**

ğŸ“Œ **Key Takeaways:**  
âœ… **Redo logs are NOT broadcast to all storage nodes**â€”only the nodes that store the affected shards receive them.  
âœ… **Storage nodes ignore redo logs that do not belong to their data partitions.**  
âœ… **This approach ensures efficient storage and network bandwidth usage.**

---

## ğŸ”„ **2ï¸âƒ£ Does Aurora Apply Writes in Memory or Directly on Disk?**

âœ” Unlike traditional databases that **write changes to data pages immediately**, Aurora **only writes Redo Logs first**.  
âœ” The **actual modification to data pages happens asynchronously in the background**.

### ğŸ”¹ **Write Process in Detail**

- **Step 1:** Redo logs are written **directly to storage** (not modifying data pages yet).
- **Step 2:** The **in-memory buffer cache** (shared by the primary and replica nodes) **holds recently accessed pages**.
- **Step 3:** When the primary instance queries data, it **checks if the page exists in memory**:
  - âœ… **If the page is in memory** â†’ It is modified directly in RAM.
  - âŒ **If the page is NOT in memory** â†’ Aurora **reads the Redo Logs and reconstructs the page on demand**.
- **Step 4:** Storage nodes **periodically flush modified pages to disk asynchronously**.

ğŸ“Œ **Key Takeaways:**  
âœ… Aurora **does not immediately modify data pages on disk**â€”instead, it **stores redo logs first** and reconstructs pages as needed.  
âœ… **Read replicas do not need WAL logs**â€”they can simply **reconstruct the latest page from redo logs in storage.**  
âœ… **Storage nodes use a page cache to speed up reads and reduce disk I/O.**

---

## ğŸ¯ **3ï¸âƒ£ How Does Aurora Handle Multiple Databases in a Cluster?**

Aurora **supports multiple databases within a single cluster**. Hereâ€™s how it works:

### ğŸ”¹ **How Storage Nodes Handle Multiple Databases**

âœ” **All databases in an Aurora cluster share the same distributed storage layer.**  
âœ” **Each Protection Group (10GB shard) contains data from multiple databases within the same cluster.**  
âœ” **Storage nodes manage storage at the page level**, meaning they **store pages from different databases but still organize them separately**.

### ğŸ”¹ **Example: Aurora Cluster with 3 Databases**

| **Database**   | **Shard 1 (Node A, C, E)** | **Shard 2 (Node B, D, F)** | **Shard 3 (Node G, H, I)** |
| -------------- | -------------------------- | -------------------------- | -------------------------- |
| **Database 1** | âœ… Stored in this shard    | âŒ Not in this shard       | âœ… Stored in this shard    |
| **Database 2** | âœ… Stored in this shard    | âœ… Stored in this shard    | âŒ Not in this shard       |
| **Database 3** | âŒ Not in this shard       | âœ… Stored in this shard    | âœ… Stored in this shard    |

ğŸ“Œ **Key Takeaways:**  
âœ… Aurora **does not separate storage per database**â€”all databases share the same **distributed storage layer**.  
âœ… Storage nodes **store pages from multiple databases but organize them efficiently at the page level**.  
âœ… **Queries still work normally**â€”Auroraâ€™s Query Engine determines where to fetch data **without modifying queries**.

---

## ğŸ“Š **4ï¸âƒ£ Corrected Write Sequence Diagram**

```mermaid
sequenceDiagram
    participant Client as Client
    participant QueryEngine as Aurora Query Engine (Primary DB)
    participant StoragePool1 as Storage Pool (AZ1)
    participant StorageNodeA as Storage Node A (Shard 1)
    participant StorageNodeB as Storage Node B (Shard 2)
    participant StoragePool2 as Storage Pool (AZ2)
    participant StorageNodeC as Storage Node C (Shard 1)
    participant StorageNodeD as Storage Node D (Shard 2)
    participant StoragePool3 as Storage Pool (AZ3)
    participant StorageNodeE as Storage Node E (Shard 1)
    participant StorageNodeF as Storage Node F (Shard 2)

    Client->>QueryEngine: Write Request (INSERT INTO orders VALUES (123))
    QueryEngine->>StoragePool1: Identify Data Location & Send Redo Log
    StoragePool1->>StorageNodeA: Write Redo Log for Shard 1
    StoragePool1->>StorageNodeB: Ignore (Not related to this shard)

    QueryEngine->>StoragePool2: Identify Data Location & Send Redo Log
    StoragePool2->>StorageNodeC: Write Redo Log for Shard 1
    StoragePool2->>StorageNodeD: Ignore (Not related to this shard)

    QueryEngine->>StoragePool3: Identify Data Location & Send Redo Log
    StoragePool3->>StorageNodeE: Write Redo Log for Shard 1
    StoragePool3->>StorageNodeF: Ignore (Not related to this shard)

    StorageNodeA->>QueryEngine: ACK (Confirmed)
    StorageNodeC->>QueryEngine: ACK (Confirmed)
    StorageNodeE->>QueryEngine: ACK (Confirmed)

    QueryEngine->>Client: Transaction Committed (Quorum Achieved)
```

ğŸ“Œ **What This Shows:**
âœ” **Redo logs are only sent to storage nodes that contain the relevant shard.**  
âœ” **Unrelated storage nodes ignore the write request.**  
âœ” **A quorum of 4/6 nodes must confirm the write before committing.**

---

## ğŸ”¥ **5ï¸âƒ£ Final Summary: How Aurora Handles Writes and Storage Efficiently**

| **Feature**                                | **Auroraâ€™s Implementation**                                                            |
| ------------------------------------------ | -------------------------------------------------------------------------------------- |
| **How Writes Are Applied**                 | Redo Logs are **written first**, data pages are **updated later in memory & disk**     |
| **How Redo Logs are Distributed**          | **Sent only to storage nodes** that store the affected shard                           |
| **How Pages Are Updated**                  | Modified **first in memory**, then **flushed to disk asynchronously**                  |
| **How Aurora Supports Multiple Databases** | **All databases share the same storage layer**, but pages are **organized separately** |
| **How Aurora Handles Scaling**             | **Storage automatically expands beyond 100TB**, with **zero downtime**                 |

ğŸ’¡ **Final Thought:**  
âœ” **Aurora is NOT like traditional databases that apply writes directly to data pagesâ€”it uses a Redo Log-based storage system for efficiency.**  
âœ” **Redo Logs are only sent to relevant storage nodes, reducing unnecessary writes and improving performance.**  
âœ” **Multiple databases in an Aurora cluster share the same storage layer but are logically organized at the page level.**

ğŸ“Œ **Would you like a deep dive into how Aurora handles crash recovery and failover? ğŸš€ğŸ”¥**
